#include "ns3/type-id.h"
#include "ns3/type-name.h"
#include "cache-manager.h"
#include "named-content-cache.h"
#include "ns3/ptr.h"
#include "ns3/packet.h"
#include "sublayer-protocol.h"
#include "ns3/ipv4-header.h"

namespace ns3{
namespace oicn{

TypeId CacheManager::GetTypeId (void)
{
	
  static TypeId tid = TypeId ("ns3::oicn::CacheManager")
    .SetParent<Object> ()
    .AddConstructor<CacheManager> ();

  return tid;


}

CacheManager::CacheManager ()
   : host_address(0)
{

}

virtual CacheManger::~CacheManager()
{

}

inline void CacheManager::SetHostAddress (uint32_t HostAddress)
{
	host_address = HostAddress;
}

inline uint32_t CacheManager::GetHostAddress ()
{
	return (host_address);
}

bool CacheManager::SetEntry (Ptr<Packet> packet1, uint8_t Name, Ipv4Header ipheader)
{
 // A cache entry is created and its corresponding index is also calculated based on custom policies
 Ptr<NamedContentCache> namedcontentcache;
 uint64_t index;
 index = namedcontentcache->CreateIndex(namedcontentcache.CreateEntry(Name, packet1, ipheader));
 // Check if the cache is full before inserting, and insert after eviction.
 if (namedcontentcache->IsFull())
 {
    if (namedcontentcache->IsEvictable(index))   /*This check is required because some policies may
                                                                              not allow blind eviction. */
    {
      // Eviction will be done by EvictEntry() and will return the name evicted

      InformICNManagerAboutEvict (GetHostAddress(), namedcontentcache.EvictEntry());
      namedcontentcache->InsertToCache(Name, entry);
      namedcontentcache->InsertToPolicyIndex(index, Name);
      /* CacheManager will send its local ip address along with the packet name so that the  ICN 
          Manager can update its table. */
      InformICNManagerAboutInsert (host_address, Name);
      return true;
    }
   /* The entry was not cached because its index was not higher than the lowest entry already 
       existing in the cache. */
   else return false;
 }
 // Insert if cache is not full.
 else 
{
   namedcontentcache->InsertToCache(Name, entry);
   namedcontentcache->InsertToPolicyIndex(index, Name);
   InformICNManagerAboutInsert (GetHostAddress(), Name);
   return true;      
}
}

void CacheManager::InformICNManagerAboutEvict (uint32_t HostAddress, uint8_t Name)
{

}

void CacheManager::InformICNManagerAboutInsert (uint32_t HostAddress, uint8_t Name)
{

}
// ICN Manager will send a message to Cache Manager to retreive data from Named Content Cache.
// The message will contain the Name of the data to be retreived.
 
void CacheManager::RequestFromICNManager (uint8_t Name, uint32_t DestinationAddress, uint32_t PortNumber)
{
   /* This function currently will just receive a dummy request from a dummy ICN Manager. When
      the ICN Manager is completely designed, the Cache Manager will receive a SDN type packet
      from it. This method then will be renamed Receive, just like Ipv4L3Protocol::Receive, and
      will decode the packet and retreive the Name and Destination Address. */

  packet = NamedContentCache::Find(Name);  /* Finds the data packet and returns it. The packet is
                                                                          in serialized form without any header from layers 
                                                                          lower than the application layer. */
  SublayerProtocol::ConstructPacket (Ptr<Packet> packet, uint8_t Name, uint32_t DestinationAddress, uint32_t PortNumber);
}
} // end of namespace oicn
} // end of namespace ns3
