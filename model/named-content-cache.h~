#ifndef NAMED_CONTENT_CACHE_H
#define NAMED_CONTENT_CACHE_H

#include "ns3/ptr.h"
#include "ns3/packet.h"
#include "named-content-cache-entry.h"
#include "ns3/type-name.h"
#include "ns3/object.h"
#include "ns3/type-id.h"
#include "ns3/ipv4-header.h"

#include <stdint.h>
#include <string>
#include <boost/unordered_map.hpp>
#include <boost/bimap.hpp>
#include <boost/bimap/bimap.hpp>
#include <boost/bimap/multiset_of.hpp>
#include <boost/bimap/detail/bimap_core.hpp>
#include <boost/bimap/unordered_set_of.hpp>

namespace ns3{
//namespace oicn{

/* This is a base class for a cache in the ICN Router. Some functions which are defined here, like  
   inserting elements, eviction and checking for cache overflow, will be common for all subclasses.
   Other functions, creating entry, calculating indexes based on policies and updating indexes differ
   from subclass to subclass. */ 

class NamedContentCache : public Object
{
public:

 /* The main cache container which stores the data buffer and corresponding name is an
    unordered_map. This is because we don't need our cache entry to sorted unnecessarily. The
    second container performs the indexing of the data buffer, represented by its name, using the
    parameters available in NamedContentCacheEntry. */
   static TypeId GetTypeId (void);

   typedef boost::unordered_map <std::string, NamedContentCacheEntry> Cache;

 /* We use a boost::bimap for the indexed container. A bimap is required because we'll be searching
    for both index and name for the purpose of eviction and updation respectively. */

   typedef boost::bimap<boost::bimaps::multiset_of<float>, boost::bimaps::unordered_set_of<std::string>> PolicyIndex;
   typedef PolicyIndex::left_map::iterator left_iterator;
   typedef PolicyIndex::right_map::iterator right_iterator;
   typedef PolicyIndex::left_map::const_iterator const_left_iterator;
   typedef PolicyIndex::right_map::const_iterator const_right_iterator;

   NamedContentCache();
   virtual ~NamedContentCache();
   //virtual void SetHostAddress(uint32_t address)= 0;
   //virtual uint32_t GetHostAddress(void)= 0;
   virtual void SetCacheSize(uint32_t size)= 0;
   virtual uint32_t GetCacheSize(void)= 0;
   virtual void SetFreshnessTime(uint64_t time)= 0;
   virtual uint64_t GetFreshnessTime(void)= 0;
   virtual NamedContentCacheEntry CreateEntry(std::string Name, Ptr<Packet> packet, Ipv4Header ipheader)= 0;
   virtual float CreateIndex(NamedContentCacheEntry entry) = 0;
   virtual void InsertToCache(std::string Name, NamedContentCacheEntry entry)= 0;
   virtual void InsertToPolicyIndex(float index, std::string Name)= 0;
   virtual bool IsFull(void)= 0;
   virtual bool IsEvictable(float index) = 0;
   virtual std::string EvictEntry(void) = 0;
   virtual Ptr<Packet> Find(std::string Name)= 0;
   virtual void UpdateIndex(std::string Name) = 0;

};
//} // end of namespace ns3
} // end of namespace oicn
#endif
