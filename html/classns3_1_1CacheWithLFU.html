<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OICNSIM: ns3::CacheWithLFU Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OICNSIM
   </div>
   <div id="projectbrief">OICNSIM(OverlayICN)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacens3.html">ns3</a></li><li class="navelem"><a class="el" href="classns3_1_1CacheWithLFU.html">CacheWithLFU</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classns3_1_1CacheWithLFU-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ns3::CacheWithLFU Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements the Least Frequently Used caching policy.  
 <a href="classns3_1_1CacheWithLFU.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache-with-lfu_8h_source.html">cache-with-lfu.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ns3::CacheWithLFU:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classns3_1_1CacheWithLFU.png" usemap="#ns3::CacheWithLFU_map" alt=""/>
  <map id="ns3::CacheWithLFU_map" name="ns3::CacheWithLFU_map">
<area href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. " alt="ns3::NamedContentCache" shape="rect" coords="0,56,157,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9d8c2b3be42315700e643d8f2a05ffe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#ac9d8c2b3be42315700e643d8f2a05ffe">CacheWithLFU</a> ()</td></tr>
<tr class="separator:ac9d8c2b3be42315700e643d8f2a05ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21e5631c7e1541f819162510d093a04"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#af21e5631c7e1541f819162510d093a04">~CacheWithLFU</a> ()</td></tr>
<tr class="separator:af21e5631c7e1541f819162510d093a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bda10cdbc2edca79e6efe8e4fac60e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a80bda10cdbc2edca79e6efe8e4fac60e">SetCacheSize</a> (uint32_t size)</td></tr>
<tr class="memdesc:a80bda10cdbc2edca79e6efe8e4fac60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache size of the Cache.  <a href="#a80bda10cdbc2edca79e6efe8e4fac60e">More...</a><br/></td></tr>
<tr class="separator:a80bda10cdbc2edca79e6efe8e4fac60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d58ee7990ca6ecf0db3fea70bdc09ef"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a2d58ee7990ca6ecf0db3fea70bdc09ef">GetCacheSize</a> (void)</td></tr>
<tr class="memdesc:a2d58ee7990ca6ecf0db3fea70bdc09ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache size of the Cache.  <a href="#a2d58ee7990ca6ecf0db3fea70bdc09ef">More...</a><br/></td></tr>
<tr class="separator:a2d58ee7990ca6ecf0db3fea70bdc09ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5fc35d85cee3f4b405ccabd977662b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a3f5fc35d85cee3f4b405ccabd977662b">SetFreshnessTime</a> (uint64_t time)</td></tr>
<tr class="memdesc:a3f5fc35d85cee3f4b405ccabd977662b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the freshness time for the contents of Cache.  <a href="#a3f5fc35d85cee3f4b405ccabd977662b">More...</a><br/></td></tr>
<tr class="separator:a3f5fc35d85cee3f4b405ccabd977662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a3e1d0b4b308a51ccf58dce5df9bee"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a27a3e1d0b4b308a51ccf58dce5df9bee">GetFreshnessTime</a> (void)</td></tr>
<tr class="memdesc:a27a3e1d0b4b308a51ccf58dce5df9bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the freshness time set for the contents of Cache.  <a href="#a27a3e1d0b4b308a51ccf58dce5df9bee">More...</a><br/></td></tr>
<tr class="separator:a27a3e1d0b4b308a51ccf58dce5df9bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a07a5f2af6c8532ee1a729d252f68"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a214a07a5f2af6c8532ee1a729d252f68">CreateEntry</a> (std::string Name, Ptr&lt; Packet &gt; packet, Ipv4Header ipheader)</td></tr>
<tr class="memdesc:a214a07a5f2af6c8532ee1a729d252f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the Cache entry, which is an object of <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class. The subclasses will define this function to create an entry that has the requisite parameters of the content, for the purpose of indexing content according to caching policy the subclass represents.  <a href="#a214a07a5f2af6c8532ee1a729d252f68">More...</a><br/></td></tr>
<tr class="separator:a214a07a5f2af6c8532ee1a729d252f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1c53863063d36a20aab3e643301119"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a8c1c53863063d36a20aab3e643301119">CreateIndex</a> (<a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> entry)</td></tr>
<tr class="memdesc:a8c1c53863063d36a20aab3e643301119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the index of the corresponding entry, by using the parameters of the content present in the entry class. The subclasses will define this function to create an index which, when put in order, will arrange the contents according to the caching policy the subclass represents. If some subclasses need decimal indexes, they have to multiply the obtained index with a factor to ensure unique integer indexes are obtained.  <a href="#a8c1c53863063d36a20aab3e643301119">More...</a><br/></td></tr>
<tr class="separator:a8c1c53863063d36a20aab3e643301119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d1afb801554e39390c07d07d33d5e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a85d1afb801554e39390c07d07d33d5e7">InsertToCache</a> (std::string Name, <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> entry)</td></tr>
<tr class="memdesc:a85d1afb801554e39390c07d07d33d5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the Name of the content and its corresponding entry object to the Cache.  <a href="#a85d1afb801554e39390c07d07d33d5e7">More...</a><br/></td></tr>
<tr class="separator:a85d1afb801554e39390c07d07d33d5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5741df65535e31319d6d534ff1f8aa2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a5741df65535e31319d6d534ff1f8aa2f">InsertToPolicyIndex</a> (uint32_t index, std::string Name)</td></tr>
<tr class="memdesc:a5741df65535e31319d6d534ff1f8aa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the index of the content and its corresponding name to the PolicyIndex.  <a href="#a5741df65535e31319d6d534ff1f8aa2f">More...</a><br/></td></tr>
<tr class="separator:a5741df65535e31319d6d534ff1f8aa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791ed7f4bebc707e18852e346f536bd8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a791ed7f4bebc707e18852e346f536bd8">IsFull</a> (void)</td></tr>
<tr class="memdesc:a791ed7f4bebc707e18852e346f536bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Cache is full, i.e. if the number of contents is equal the cache size.  <a href="#a791ed7f4bebc707e18852e346f536bd8">More...</a><br/></td></tr>
<tr class="separator:a791ed7f4bebc707e18852e346f536bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4999cd730f44907c1fdf3f8ea11f4de1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a4999cd730f44907c1fdf3f8ea11f4de1">IsUnique</a> (std::string Name)</td></tr>
<tr class="memdesc:a4999cd730f44907c1fdf3f8ea11f4de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">it check whether content is present in the cache or not  <a href="#a4999cd730f44907c1fdf3f8ea11f4de1">More...</a><br/></td></tr>
<tr class="separator:a4999cd730f44907c1fdf3f8ea11f4de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac9bfbe6e1b12952c345051517b762f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a4ac9bfbe6e1b12952c345051517b762f">IsEvictable</a> (uint32_t index)</td></tr>
<tr class="memdesc:a4ac9bfbe6e1b12952c345051517b762f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the content with the given index can be inserted with the eviction of some other content when the is full. The new content can be inserted if its index is lesser than (or greater than, when arranged in descending order) the first content, or if any content's freshness has expired. Some caching policies, like FIFO, keep on inserting new content, irrespective of its index. Subclasses representing such policies need not define and use this function.  <a href="#a4ac9bfbe6e1b12952c345051517b762f">More...</a><br/></td></tr>
<tr class="separator:a4ac9bfbe6e1b12952c345051517b762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dda5e2a61f82f7eaa2121a2de2f5a8f"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a9dda5e2a61f82f7eaa2121a2de2f5a8f">EvictEntry</a> (void)</td></tr>
<tr class="memdesc:a9dda5e2a61f82f7eaa2121a2de2f5a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict the first content in PolicyIndex and also the corresponding entry in the Cache. This is the main eviction function of <a class="el" href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. ">NamedContentCache</a>.  <a href="#a9dda5e2a61f82f7eaa2121a2de2f5a8f">More...</a><br/></td></tr>
<tr class="separator:a9dda5e2a61f82f7eaa2121a2de2f5a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04d4be1c2ea84020f5eac561a8ebe22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#aa04d4be1c2ea84020f5eac561a8ebe22">EvictEntry</a> (std::string Name)</td></tr>
<tr class="memdesc:aa04d4be1c2ea84020f5eac561a8ebe22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict the content with corresponding name from both PolicyIndex and Cache. This has to be done when a packet having a content that already exists in the Cache has been received the ICN Router. This operation basically evicts the older entry of the same content so that the newer entry can be inserted. This function has to be defined by all subclasses because every content name in Cache and PolicyIndex has to be unique.  <a href="#aa04d4be1c2ea84020f5eac561a8ebe22">More...</a><br/></td></tr>
<tr class="separator:aa04d4be1c2ea84020f5eac561a8ebe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36841e8b113ed62ad8827785fa03740"><td class="memItemLeft" align="right" valign="top">virtual Ptr&lt; Packet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#af36841e8b113ed62ad8827785fa03740">Find</a> (std::string Name)</td></tr>
<tr class="memdesc:af36841e8b113ed62ad8827785fa03740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the content with given name in the Cache.  <a href="#af36841e8b113ed62ad8827785fa03740">More...</a><br/></td></tr>
<tr class="separator:af36841e8b113ed62ad8827785fa03740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b99b7a3c9a1e8d7fb2c5b2946f69c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a3b6b99b7a3c9a1e8d7fb2c5b2946f69c">UpdateIndex</a> (std::string Name)</td></tr>
<tr class="memdesc:a3b6b99b7a3c9a1e8d7fb2c5b2946f69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the index of the content with the given name. This has to be done when the content is retrieved from Cache to be sent to a querying OICN Client. The subclasses will define this function based on the requirements of the caching policies they represent.  <a href="#a3b6b99b7a3c9a1e8d7fb2c5b2946f69c">More...</a><br/></td></tr>
<tr class="separator:a3b6b99b7a3c9a1e8d7fb2c5b2946f69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classns3_1_1NamedContentCache"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classns3_1_1NamedContentCache')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classns3_1_1NamedContentCache.html">ns3::NamedContentCache</a></td></tr>
<tr class="memitem:a4c6df9dacea268223c7a1cb9f17de93d inherit pub_methods_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a4c6df9dacea268223c7a1cb9f17de93d">NamedContentCache</a> ()</td></tr>
<tr class="separator:a4c6df9dacea268223c7a1cb9f17de93d inherit pub_methods_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872f6440953cb44223b8584757f6bcfd inherit pub_methods_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a872f6440953cb44223b8584757f6bcfd">~NamedContentCache</a> ()</td></tr>
<tr class="separator:a872f6440953cb44223b8584757f6bcfd inherit pub_methods_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abdbb868fedff87f723423726c8f52d18"><td class="memItemLeft" align="right" valign="top">static TypeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#abdbb868fedff87f723423726c8f52d18">GetTypeId</a> (void)</td></tr>
<tr class="memdesc:abdbb868fedff87f723423726c8f52d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID.  <a href="#abdbb868fedff87f723423726c8f52d18">More...</a><br/></td></tr>
<tr class="separator:abdbb868fedff87f723423726c8f52d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classns3_1_1NamedContentCache"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classns3_1_1NamedContentCache')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classns3_1_1NamedContentCache.html">ns3::NamedContentCache</a></td></tr>
<tr class="memitem:a6e1837a2d8896d7a53c7a8b1d3a472d3 inherit pub_static_methods_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">static TypeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a6e1837a2d8896d7a53c7a8b1d3a472d3">GetTypeId</a> (void)</td></tr>
<tr class="memdesc:a6e1837a2d8896d7a53c7a8b1d3a472d3 inherit pub_static_methods_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID.  <a href="#a6e1837a2d8896d7a53c7a8b1d3a472d3">More...</a><br/></td></tr>
<tr class="separator:a6e1837a2d8896d7a53c7a8b1d3a472d3 inherit pub_static_methods_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a79d5772bfd23f574af448f95c223417c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a79d5772bfd23f574af448f95c223417c">cache_size</a></td></tr>
<tr class="memdesc:a79d5772bfd23f574af448f95c223417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the Cache  <a href="#a79d5772bfd23f574af448f95c223417c">More...</a><br/></td></tr>
<tr class="separator:a79d5772bfd23f574af448f95c223417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab1e97d5de9b643e4b29f80e971294b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1NamedContentCache.html#a9aa35d883b9f4153d97b6e7dc74f9307">Cache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a8ab1e97d5de9b643e4b29f80e971294b">cache</a></td></tr>
<tr class="memdesc:a8ab1e97d5de9b643e4b29f80e971294b"><td class="mdescLeft">&#160;</td><td class="mdescRight">main cache container which stores the name and corresponding content  <a href="#a8ab1e97d5de9b643e4b29f80e971294b">More...</a><br/></td></tr>
<tr class="separator:a8ab1e97d5de9b643e4b29f80e971294b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17cdaaa0686b2fd2171d98ad767eec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classns3_1_1NamedContentCache.html#a0b728ea2d4e0acbe431897b2374cfc8e">PolicyIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#ae17cdaaa0686b2fd2171d98ad767eec5">policyindex</a></td></tr>
<tr class="memdesc:ae17cdaaa0686b2fd2171d98ad767eec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">policy indexed container, containing index and content name  <a href="#ae17cdaaa0686b2fd2171d98ad767eec5">More...</a><br/></td></tr>
<tr class="separator:ae17cdaaa0686b2fd2171d98ad767eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8301a27e2e133723a181782ed791c3b0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1CacheWithLFU.html#a8301a27e2e133723a181782ed791c3b0">freshness_time</a></td></tr>
<tr class="memdesc:a8301a27e2e133723a181782ed791c3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">time after which the cache should be evicted  <a href="#a8301a27e2e133723a181782ed791c3b0">More...</a><br/></td></tr>
<tr class="separator:a8301a27e2e133723a181782ed791c3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classns3_1_1NamedContentCache"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classns3_1_1NamedContentCache')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classns3_1_1NamedContentCache.html">ns3::NamedContentCache</a></td></tr>
<tr class="memitem:a9aa35d883b9f4153d97b6e7dc74f9307 inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef boost::unordered_map<br class="typebreak"/>
&lt; std::string, <br class="typebreak"/>
<a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a9aa35d883b9f4153d97b6e7dc74f9307">Cache</a></td></tr>
<tr class="memdesc:a9aa35d883b9f4153d97b6e7dc74f9307 inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main cache container which stores the data buffer and corresponding name is a boost::unordered_map. This is because we don't need our cache entry to be sorted unnecessarily.  <a href="#a9aa35d883b9f4153d97b6e7dc74f9307">More...</a><br/></td></tr>
<tr class="separator:a9aa35d883b9f4153d97b6e7dc74f9307 inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b728ea2d4e0acbe431897b2374cfc8e inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef boost::bimap<br class="typebreak"/>
&lt; boost::bimaps::multiset_of<br class="typebreak"/>
&lt; uint32_t &gt;<br class="typebreak"/>
, boost::bimaps::unordered_set_of<br class="typebreak"/>
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a0b728ea2d4e0acbe431897b2374cfc8e">PolicyIndex</a></td></tr>
<tr class="memdesc:a0b728ea2d4e0acbe431897b2374cfc8e inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed container which is necessary for the purpose of eviction based on caching policy, is a boost::bimap. A bimap is required because we'll be searching for both index and name for the purpose of eviction and updation respectively.  <a href="#a0b728ea2d4e0acbe431897b2374cfc8e">More...</a><br/></td></tr>
<tr class="separator:a0b728ea2d4e0acbe431897b2374cfc8e inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f52ee3d115d1b5fdd1201620b889b6e inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::left_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a0f52ee3d115d1b5fdd1201620b889b6e">left_iterator</a></td></tr>
<tr class="memdesc:a0f52ee3d115d1b5fdd1201620b889b6e inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the iterator of the left map of PolicyIndex.  <a href="#a0f52ee3d115d1b5fdd1201620b889b6e">More...</a><br/></td></tr>
<tr class="separator:a0f52ee3d115d1b5fdd1201620b889b6e inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c391c6013b29596a2ec5c62d0e413ed inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::right_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a2c391c6013b29596a2ec5c62d0e413ed">right_iterator</a></td></tr>
<tr class="memdesc:a2c391c6013b29596a2ec5c62d0e413ed inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the iterator of the right map of PolicyIndex.  <a href="#a2c391c6013b29596a2ec5c62d0e413ed">More...</a><br/></td></tr>
<tr class="separator:a2c391c6013b29596a2ec5c62d0e413ed inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b957fbf37ee4eb873db49705bc388 inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::left_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a061b957fbf37ee4eb873db49705bc388">const_left_iterator</a></td></tr>
<tr class="memdesc:a061b957fbf37ee4eb873db49705bc388 inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the constant iterator of the left map of PolicyIndex.  <a href="#a061b957fbf37ee4eb873db49705bc388">More...</a><br/></td></tr>
<tr class="separator:a061b957fbf37ee4eb873db49705bc388 inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489e77c6528954d887b8ff107a1244f inherit pub_types_classns3_1_1NamedContentCache"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::right_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a7489e77c6528954d887b8ff107a1244f">const_right_iterator</a></td></tr>
<tr class="memdesc:a7489e77c6528954d887b8ff107a1244f inherit pub_types_classns3_1_1NamedContentCache"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the constant iterator of the right map of PolicyIndex.  <a href="#a7489e77c6528954d887b8ff107a1244f">More...</a><br/></td></tr>
<tr class="separator:a7489e77c6528954d887b8ff107a1244f inherit pub_types_classns3_1_1NamedContentCache"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the Least Frequently Used caching policy. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac9d8c2b3be42315700e643d8f2a05ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::CacheWithLFU::CacheWithLFU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af21e5631c7e1541f819162510d093a04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ns3::CacheWithLFU::~CacheWithLFU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a214a07a5f2af6c8532ee1a729d252f68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> ns3::CacheWithLFU::CreateEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&lt; Packet &gt;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipv4Header&#160;</td>
          <td class="paramname"><em>ipheader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the Cache entry, which is an object of <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class. The subclasses will define this function to create an entry that has the requisite parameters of the content, for the purpose of indexing content according to caching policy the subclass represents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
    <tr><td class="paramname">packet</td><td>packet received by ICN Router, with its IP, Transport and OICN headers removed </td></tr>
    <tr><td class="paramname">ipheader</td><td>ip header of the packet, from which the required parameters of the content (present in packet) can retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created cache entry </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a154317526b3883db729c365ab342074a">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a8c1c53863063d36a20aab3e643301119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::CacheWithLFU::CreateIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the index of the corresponding entry, by using the parameters of the content present in the entry class. The subclasses will define this function to create an index which, when put in order, will arrange the contents according to the caching policy the subclass represents. If some subclasses need decimal indexes, they have to multiply the obtained index with a factor to ensure unique integer indexes are obtained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the cache entry corresponding to the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created integer index for the content </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a75be49c2ad5db93bdf8aaed813dcf304">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a9dda5e2a61f82f7eaa2121a2de2f5a8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ns3::CacheWithLFU::EvictEntry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict the first content in PolicyIndex and also the corresponding entry in the Cache. This is the main eviction function of <a class="el" href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. ">NamedContentCache</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the evicted content </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a87850f01fc632ede64af75d7c20f7a7e">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="aa04d4be1c2ea84020f5eac561a8ebe22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::EvictEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict the content with corresponding name from both PolicyIndex and Cache. This has to be done when a packet having a content that already exists in the Cache has been received the ICN Router. This operation basically evicts the older entry of the same content so that the newer entry can be inserted. This function has to be defined by all subclasses because every content name in Cache and PolicyIndex has to be unique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the non-unique content </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a254f3c74475e104a615739fc7577296f">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="af36841e8b113ed62ad8827785fa03740"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Ptr&lt; Packet &gt; ns3::CacheWithLFU::Find </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the content with given name in the Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the content in the form of an Application Layer packet </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a081439cd96d09e2f9f158f3aebe9fd7c">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a2d58ee7990ca6ecf0db3fea70bdc09ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::CacheWithLFU::GetCacheSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache size of the Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the cache size of the Cache </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#afd9ade17d87082a46cbb745fd0196ab4">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a27a3e1d0b4b308a51ccf58dce5df9bee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ns3::CacheWithLFU::GetFreshnessTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the freshness time set for the contents of Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the freshness time in milliseconds </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#ac2b0e616d4e866cb2328e986f2ef69e1">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="abdbb868fedff87f723423726c8f52d18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypeId ns3::CacheWithLFU::GetTypeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type ID. </p>
<dl class="section return"><dt>Returns</dt><dd>the object TypeId </dd></dl>

</div>
</div>
<a class="anchor" id="a85d1afb801554e39390c07d07d33d5e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::InsertToCache </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the Name of the content and its corresponding entry object to the Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
    <tr><td class="paramname">entry</td><td>the cache entry corresponding to the content </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a56a23add9b5bc03908793cf261ccb5f8">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a5741df65535e31319d6d534ff1f8aa2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::InsertToPolicyIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the index of the content and its corresponding name to the PolicyIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the unique integer index of the content </td></tr>
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#ac248e647f56a6fef10285b1c654b8180">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a4ac9bfbe6e1b12952c345051517b762f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::CacheWithLFU::IsEvictable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the content with the given index can be inserted with the eviction of some other content when the is full. The new content can be inserted if its index is lesser than (or greater than, when arranged in descending order) the first content, or if any content's freshness has expired. Some caching policies, like FIFO, keep on inserting new content, irrespective of its index. Subclasses representing such policies need not define and use this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the unique integer index of the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any existing content can be evicted so that the new content with the given index can be inserted. </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a281ad340f9771fa2ed898a1ad569d0da">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a791ed7f4bebc707e18852e346f536bd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::CacheWithLFU::IsFull </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the Cache is full, i.e. if the number of contents is equal the cache size. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the Cache is full </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a1ceeaf5b85d3571225adfe2d48caf126">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a4999cd730f44907c1fdf3f8ea11f4de1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ns3::CacheWithLFU::IsUnique </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it check whether content is present in the cache or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if content is not present, false when content is present in the cache </dd></dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a4c4a79310c99f9c8ad6227d3b380dc20">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a80bda10cdbc2edca79e6efe8e4fac60e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::SetCacheSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cache size of the Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to which the cache has to be set </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#ae28605a03a5a4d8b9a3494b4068f44e2">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a3f5fc35d85cee3f4b405ccabd977662b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::SetFreshnessTime </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the freshness time for the contents of Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the freshness time in milliseconds </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#a92a5e2e641a11d15300f621aa77275ab">ns3::NamedContentCache</a>.</p>

</div>
</div>
<a class="anchor" id="a3b6b99b7a3c9a1e8d7fb2c5b2946f69c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ns3::CacheWithLFU::UpdateIndex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the index of the content with the given name. This has to be done when the content is retrieved from Cache to be sent to a querying OICN Client. The subclasses will define this function based on the requirements of the caching policies they represent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the content whose index has to be updated </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classns3_1_1NamedContentCache.html#aeabf8afacd89cbc46b78b382c8a487e8">ns3::NamedContentCache</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8ab1e97d5de9b643e4b29f80e971294b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1NamedContentCache.html#a9aa35d883b9f4153d97b6e7dc74f9307">Cache</a> ns3::CacheWithLFU::cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>main cache container which stores the name and corresponding content </p>

</div>
</div>
<a class="anchor" id="a79d5772bfd23f574af448f95c223417c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ns3::CacheWithLFU::cache_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>size of the Cache </p>

</div>
</div>
<a class="anchor" id="a8301a27e2e133723a181782ed791c3b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ns3::CacheWithLFU::freshness_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>time after which the cache should be evicted </p>

</div>
</div>
<a class="anchor" id="ae17cdaaa0686b2fd2171d98ad767eec5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classns3_1_1NamedContentCache.html#a0b728ea2d4e0acbe431897b2374cfc8e">PolicyIndex</a> ns3::CacheWithLFU::policyindex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>policy indexed container, containing index and content name </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/<a class="el" href="cache-with-lfu_8h_source.html">cache-with-lfu.h</a></li>
<li>model/<a class="el" href="cache-with-lfu_8cc.html">cache-with-lfu.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 18 2016 10:26:15 for OICNSIM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
