<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>OICNSIM: ns3::NamedContentCache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">OICNSIM
   </div>
   <div id="projectbrief">OICNSIM(OverlayICN)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacens3.html">ns3</a></li><li class="navelem"><a class="el" href="classns3_1_1NamedContentCache.html">NamedContentCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classns3_1_1NamedContentCache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ns3::NamedContentCache Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The base class for caching data at the ICN Router.  
 <a href="classns3_1_1NamedContentCache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="named-content-cache_8h_source.html">named-content-cache.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ns3::NamedContentCache:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classns3_1_1NamedContentCache.png" usemap="#ns3::NamedContentCache_map" alt=""/>
  <map id="ns3::NamedContentCache_map" name="ns3::NamedContentCache_map">
<area href="classns3_1_1CacheWithFifo.html" title="This class implements the first in first out caching policy. " alt="ns3::CacheWithFifo" shape="rect" coords="0,112,175,136"/>
<area href="classns3_1_1CacheWithLFU.html" title="This class implements the Least Frequently Used caching policy. " alt="ns3::CacheWithLFU" shape="rect" coords="185,112,360,136"/>
<area href="classns3_1_1CacheWithLRU.html" title="This class implements the Least Recently Used caching policy. " alt="ns3::CacheWithLRU" shape="rect" coords="370,112,545,136"/>
<area href="classns3_1_1SimpleUniversalCaching.html" title="This class implements the Universal caching policy. " alt="ns3::SimpleUniversalCaching" shape="rect" coords="555,112,730,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9aa35d883b9f4153d97b6e7dc74f9307"><td class="memItemLeft" align="right" valign="top">typedef boost::unordered_map<br class="typebreak"/>
&lt; std::string, <br class="typebreak"/>
<a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a9aa35d883b9f4153d97b6e7dc74f9307">Cache</a></td></tr>
<tr class="memdesc:a9aa35d883b9f4153d97b6e7dc74f9307"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main cache container which stores the data buffer and corresponding name is a boost::unordered_map. This is because we don't need our cache entry to be sorted unnecessarily.  <a href="#a9aa35d883b9f4153d97b6e7dc74f9307">More...</a><br/></td></tr>
<tr class="separator:a9aa35d883b9f4153d97b6e7dc74f9307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b728ea2d4e0acbe431897b2374cfc8e"><td class="memItemLeft" align="right" valign="top">typedef boost::bimap<br class="typebreak"/>
&lt; boost::bimaps::multiset_of<br class="typebreak"/>
&lt; uint32_t &gt;<br class="typebreak"/>
, boost::bimaps::unordered_set_of<br class="typebreak"/>
&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a0b728ea2d4e0acbe431897b2374cfc8e">PolicyIndex</a></td></tr>
<tr class="memdesc:a0b728ea2d4e0acbe431897b2374cfc8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexed container which is necessary for the purpose of eviction based on caching policy, is a boost::bimap. A bimap is required because we'll be searching for both index and name for the purpose of eviction and updation respectively.  <a href="#a0b728ea2d4e0acbe431897b2374cfc8e">More...</a><br/></td></tr>
<tr class="separator:a0b728ea2d4e0acbe431897b2374cfc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f52ee3d115d1b5fdd1201620b889b6e"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::left_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a0f52ee3d115d1b5fdd1201620b889b6e">left_iterator</a></td></tr>
<tr class="memdesc:a0f52ee3d115d1b5fdd1201620b889b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the iterator of the left map of PolicyIndex.  <a href="#a0f52ee3d115d1b5fdd1201620b889b6e">More...</a><br/></td></tr>
<tr class="separator:a0f52ee3d115d1b5fdd1201620b889b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c391c6013b29596a2ec5c62d0e413ed"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::right_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a2c391c6013b29596a2ec5c62d0e413ed">right_iterator</a></td></tr>
<tr class="memdesc:a2c391c6013b29596a2ec5c62d0e413ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the iterator of the right map of PolicyIndex.  <a href="#a2c391c6013b29596a2ec5c62d0e413ed">More...</a><br/></td></tr>
<tr class="separator:a2c391c6013b29596a2ec5c62d0e413ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061b957fbf37ee4eb873db49705bc388"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::left_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a061b957fbf37ee4eb873db49705bc388">const_left_iterator</a></td></tr>
<tr class="memdesc:a061b957fbf37ee4eb873db49705bc388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the constant iterator of the left map of PolicyIndex.  <a href="#a061b957fbf37ee4eb873db49705bc388">More...</a><br/></td></tr>
<tr class="separator:a061b957fbf37ee4eb873db49705bc388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489e77c6528954d887b8ff107a1244f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
PolicyIndex::right_map::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a7489e77c6528954d887b8ff107a1244f">const_right_iterator</a></td></tr>
<tr class="memdesc:a7489e77c6528954d887b8ff107a1244f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type Definition for the constant iterator of the right map of PolicyIndex.  <a href="#a7489e77c6528954d887b8ff107a1244f">More...</a><br/></td></tr>
<tr class="separator:a7489e77c6528954d887b8ff107a1244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4c6df9dacea268223c7a1cb9f17de93d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a4c6df9dacea268223c7a1cb9f17de93d">NamedContentCache</a> ()</td></tr>
<tr class="separator:a4c6df9dacea268223c7a1cb9f17de93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872f6440953cb44223b8584757f6bcfd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a872f6440953cb44223b8584757f6bcfd">~NamedContentCache</a> ()</td></tr>
<tr class="separator:a872f6440953cb44223b8584757f6bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28605a03a5a4d8b9a3494b4068f44e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#ae28605a03a5a4d8b9a3494b4068f44e2">SetCacheSize</a> (uint32_t size)=0</td></tr>
<tr class="memdesc:ae28605a03a5a4d8b9a3494b4068f44e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the cache size of the Cache.  <a href="#ae28605a03a5a4d8b9a3494b4068f44e2">More...</a><br/></td></tr>
<tr class="separator:ae28605a03a5a4d8b9a3494b4068f44e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9ade17d87082a46cbb745fd0196ab4"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#afd9ade17d87082a46cbb745fd0196ab4">GetCacheSize</a> (void)=0</td></tr>
<tr class="memdesc:afd9ade17d87082a46cbb745fd0196ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the cache size of the Cache.  <a href="#afd9ade17d87082a46cbb745fd0196ab4">More...</a><br/></td></tr>
<tr class="separator:afd9ade17d87082a46cbb745fd0196ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a5e2e641a11d15300f621aa77275ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a92a5e2e641a11d15300f621aa77275ab">SetFreshnessTime</a> (uint64_t time)=0</td></tr>
<tr class="memdesc:a92a5e2e641a11d15300f621aa77275ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the freshness time for the contents of Cache.  <a href="#a92a5e2e641a11d15300f621aa77275ab">More...</a><br/></td></tr>
<tr class="separator:a92a5e2e641a11d15300f621aa77275ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b0e616d4e866cb2328e986f2ef69e1"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#ac2b0e616d4e866cb2328e986f2ef69e1">GetFreshnessTime</a> (void)=0</td></tr>
<tr class="memdesc:ac2b0e616d4e866cb2328e986f2ef69e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the freshness time set for the contents of Cache.  <a href="#ac2b0e616d4e866cb2328e986f2ef69e1">More...</a><br/></td></tr>
<tr class="separator:ac2b0e616d4e866cb2328e986f2ef69e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154317526b3883db729c365ab342074a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a154317526b3883db729c365ab342074a">CreateEntry</a> (std::string Name, Ptr&lt; Packet &gt; packet, Ipv4Header ipheader)=0</td></tr>
<tr class="memdesc:a154317526b3883db729c365ab342074a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the Cache entry, which is an object of <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class. The subclasses will define this function to create an entry that has the requisite parameters of the content, for the purpose of indexing content according to caching policy the subclass represents.  <a href="#a154317526b3883db729c365ab342074a">More...</a><br/></td></tr>
<tr class="separator:a154317526b3883db729c365ab342074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75be49c2ad5db93bdf8aaed813dcf304"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a75be49c2ad5db93bdf8aaed813dcf304">CreateIndex</a> (<a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> entry)=0</td></tr>
<tr class="memdesc:a75be49c2ad5db93bdf8aaed813dcf304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the index of the corresponding entry, by using the parameters of the content present in the entry class. The subclasses will define this function to create an index which, when put in order, will arrange the contents according to the caching policy the subclass represents. If some subclasses need decimal indexes, they have to multiply the obtained index with a factor to ensure unique integer indexes are obtained.  <a href="#a75be49c2ad5db93bdf8aaed813dcf304">More...</a><br/></td></tr>
<tr class="separator:a75be49c2ad5db93bdf8aaed813dcf304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a23add9b5bc03908793cf261ccb5f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a56a23add9b5bc03908793cf261ccb5f8">InsertToCache</a> (std::string Name, <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> entry)=0</td></tr>
<tr class="memdesc:a56a23add9b5bc03908793cf261ccb5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the Name of the content and its corresponding entry object to the Cache.  <a href="#a56a23add9b5bc03908793cf261ccb5f8">More...</a><br/></td></tr>
<tr class="separator:a56a23add9b5bc03908793cf261ccb5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac248e647f56a6fef10285b1c654b8180"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#ac248e647f56a6fef10285b1c654b8180">InsertToPolicyIndex</a> (uint32_t index, std::string Name)=0</td></tr>
<tr class="memdesc:ac248e647f56a6fef10285b1c654b8180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert the index of the content and its corresponding name to the PolicyIndex.  <a href="#ac248e647f56a6fef10285b1c654b8180">More...</a><br/></td></tr>
<tr class="separator:ac248e647f56a6fef10285b1c654b8180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceeaf5b85d3571225adfe2d48caf126"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a1ceeaf5b85d3571225adfe2d48caf126">IsFull</a> (void)=0</td></tr>
<tr class="memdesc:a1ceeaf5b85d3571225adfe2d48caf126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the Cache is full, i.e. if the number of contents is equal the cache size.  <a href="#a1ceeaf5b85d3571225adfe2d48caf126">More...</a><br/></td></tr>
<tr class="separator:a1ceeaf5b85d3571225adfe2d48caf126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4a79310c99f9c8ad6227d3b380dc20"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a4c4a79310c99f9c8ad6227d3b380dc20">IsUnique</a> (std::string name)=0</td></tr>
<tr class="memdesc:a4c4a79310c99f9c8ad6227d3b380dc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">it check whether content is present in the cache or not  <a href="#a4c4a79310c99f9c8ad6227d3b380dc20">More...</a><br/></td></tr>
<tr class="separator:a4c4a79310c99f9c8ad6227d3b380dc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ad340f9771fa2ed898a1ad569d0da"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a281ad340f9771fa2ed898a1ad569d0da">IsEvictable</a> (uint32_t index)=0</td></tr>
<tr class="memdesc:a281ad340f9771fa2ed898a1ad569d0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the content with the given index can be inserted with the eviction of some other content when the is full. The new content can be inserted if its index is lesser than (or greater than, when arranged in descending order) the first content, or if any content's freshness has expired. Some caching policies, like FIFO, keep on inserting new content, irrespective of its index. Subclasses representing such policies need not define and use this function.  <a href="#a281ad340f9771fa2ed898a1ad569d0da">More...</a><br/></td></tr>
<tr class="separator:a281ad340f9771fa2ed898a1ad569d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87850f01fc632ede64af75d7c20f7a7e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a87850f01fc632ede64af75d7c20f7a7e">EvictEntry</a> (void)=0</td></tr>
<tr class="memdesc:a87850f01fc632ede64af75d7c20f7a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict the first content in PolicyIndex and also the corresponding entry in the Cache. This is the main eviction function of <a class="el" href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. ">NamedContentCache</a>.  <a href="#a87850f01fc632ede64af75d7c20f7a7e">More...</a><br/></td></tr>
<tr class="separator:a87850f01fc632ede64af75d7c20f7a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254f3c74475e104a615739fc7577296f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a254f3c74475e104a615739fc7577296f">EvictEntry</a> (std::string Name)=0</td></tr>
<tr class="memdesc:a254f3c74475e104a615739fc7577296f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evict the content with corresponding name from both PolicyIndex and Cache. This has to be done when a packet having a content that already exists in the Cache has been received the ICN Router. This operation basically evicts the older entry of the same content so that the newer entry can be inserted. This function has to be defined by all subclasses because every content name in Cache and PolicyIndex has to be unique.  <a href="#a254f3c74475e104a615739fc7577296f">More...</a><br/></td></tr>
<tr class="separator:a254f3c74475e104a615739fc7577296f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081439cd96d09e2f9f158f3aebe9fd7c"><td class="memItemLeft" align="right" valign="top">virtual Ptr&lt; Packet &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a081439cd96d09e2f9f158f3aebe9fd7c">Find</a> (std::string Name)=0</td></tr>
<tr class="memdesc:a081439cd96d09e2f9f158f3aebe9fd7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the content with given name in the Cache.  <a href="#a081439cd96d09e2f9f158f3aebe9fd7c">More...</a><br/></td></tr>
<tr class="separator:a081439cd96d09e2f9f158f3aebe9fd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabf8afacd89cbc46b78b382c8a487e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#aeabf8afacd89cbc46b78b382c8a487e8">UpdateIndex</a> (std::string Name)=0</td></tr>
<tr class="memdesc:aeabf8afacd89cbc46b78b382c8a487e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the index of the content with the given name. This has to be done when the content is retrieved from Cache to be sent to a querying OICN Client. The subclasses will define this function based on the requirements of the caching policies they represent.  <a href="#aeabf8afacd89cbc46b78b382c8a487e8">More...</a><br/></td></tr>
<tr class="separator:aeabf8afacd89cbc46b78b382c8a487e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6e1837a2d8896d7a53c7a8b1d3a472d3"><td class="memItemLeft" align="right" valign="top">static TypeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classns3_1_1NamedContentCache.html#a6e1837a2d8896d7a53c7a8b1d3a472d3">GetTypeId</a> (void)</td></tr>
<tr class="memdesc:a6e1837a2d8896d7a53c7a8b1d3a472d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type ID.  <a href="#a6e1837a2d8896d7a53c7a8b1d3a472d3">More...</a><br/></td></tr>
<tr class="separator:a6e1837a2d8896d7a53c7a8b1d3a472d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for caching data at the ICN Router. </p>
<p>This class is a base class for all different types of ICN Router cache, i.e. a FIFO based cache, an LRU based cache, a customized cache etc. This class provides the two essential containers required for a typical cache, a container to store the actual data, called Cache, and a container to store the index of the corresponding data, called PolicyIndex.</p>
<p>A Cache entry is an object of <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class, which is basically a struct containing the data along with various parameters corresponding to data, like timestamp, source IP etc. More about <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class can be found in its header file.</p>
<p>Depending on caching policy used by a particular subclass, the index of a content is calculated using the required parameters present in the cache entry. The <a class="el" href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. ">NamedContentCache</a> class basically contains the declarations for all required virtual functions needed for handling a cache, i.e. insertion, eviction etc.</p>
<p>This class is instantiated and aggregated to all ICN Routers in the network, and is not required in any other components of OICN Architecture.</p>
<p>Note: The word Cache here refers to the boost::unordered_map that stores the content along with its corresponding name. The word PolicyIndex refers to the boost::bimap container used for indexing the stored content in Cache. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a9aa35d883b9f4153d97b6e7dc74f9307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::unordered_map&lt;std::string, <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&gt; <a class="el" href="classns3_1_1NamedContentCache.html#a9aa35d883b9f4153d97b6e7dc74f9307">ns3::NamedContentCache::Cache</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main cache container which stores the data buffer and corresponding name is a boost::unordered_map. This is because we don't need our cache entry to be sorted unnecessarily. </p>

</div>
</div>
<a class="anchor" id="a061b957fbf37ee4eb873db49705bc388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PolicyIndex::left_map::const_iterator <a class="el" href="classns3_1_1NamedContentCache.html#a061b957fbf37ee4eb873db49705bc388">ns3::NamedContentCache::const_left_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type Definition for the constant iterator of the left map of PolicyIndex. </p>

</div>
</div>
<a class="anchor" id="a7489e77c6528954d887b8ff107a1244f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PolicyIndex::right_map::const_iterator <a class="el" href="classns3_1_1NamedContentCache.html#a7489e77c6528954d887b8ff107a1244f">ns3::NamedContentCache::const_right_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type Definition for the constant iterator of the right map of PolicyIndex. </p>

</div>
</div>
<a class="anchor" id="a0f52ee3d115d1b5fdd1201620b889b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PolicyIndex::left_map::iterator <a class="el" href="classns3_1_1NamedContentCache.html#a0f52ee3d115d1b5fdd1201620b889b6e">ns3::NamedContentCache::left_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type Definition for the iterator of the left map of PolicyIndex. </p>

</div>
</div>
<a class="anchor" id="a0b728ea2d4e0acbe431897b2374cfc8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::bimap&lt;boost::bimaps::multiset_of&lt;uint32_t&gt;, boost::bimaps::unordered_set_of&lt;std::string&gt; &gt; <a class="el" href="classns3_1_1NamedContentCache.html#a0b728ea2d4e0acbe431897b2374cfc8e">ns3::NamedContentCache::PolicyIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexed container which is necessary for the purpose of eviction based on caching policy, is a boost::bimap. A bimap is required because we'll be searching for both index and name for the purpose of eviction and updation respectively. </p>

</div>
</div>
<a class="anchor" id="a2c391c6013b29596a2ec5c62d0e413ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef PolicyIndex::right_map::iterator <a class="el" href="classns3_1_1NamedContentCache.html#a2c391c6013b29596a2ec5c62d0e413ed">ns3::NamedContentCache::right_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type Definition for the iterator of the right map of PolicyIndex. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4c6df9dacea268223c7a1cb9f17de93d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ns3::NamedContentCache::NamedContentCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a872f6440953cb44223b8584757f6bcfd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ns3::NamedContentCache::~NamedContentCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a154317526b3883db729c365ab342074a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a> ns3::NamedContentCache::CreateEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ptr&lt; Packet &gt;&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ipv4Header&#160;</td>
          <td class="paramname"><em>ipheader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the Cache entry, which is an object of <a class="el" href="classns3_1_1NamedContentCacheEntry.html" title="Entry class for NamedContentCache container of ICN Router. ">NamedContentCacheEntry</a> class. The subclasses will define this function to create an entry that has the requisite parameters of the content, for the purpose of indexing content according to caching policy the subclass represents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
    <tr><td class="paramname">packet</td><td>packet received by ICN Router, with its IP, Transport and OICN headers removed </td></tr>
    <tr><td class="paramname">ipheader</td><td>IP Header of the packet, from which the required parameters of the content (present in packet) can retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created cache entry </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a214a07a5f2af6c8532ee1a729d252f68">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a95d289d9580f5af31885b8deb9738451">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a8dc721b8593047e5246b3ffa21c83ba2">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#ae9be9920ddca0d7a001a054381c0543c">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a75be49c2ad5db93bdf8aaed813dcf304"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t ns3::NamedContentCache::CreateIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the index of the corresponding entry, by using the parameters of the content present in the entry class. The subclasses will define this function to create an index which, when put in order, will arrange the contents according to the caching policy the subclass represents. If some subclasses need decimal indexes, they have to multiply the obtained index with a factor to ensure unique integer indexes are obtained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>the cache entry corresponding to the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created integer index for the content </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a8c1c53863063d36a20aab3e643301119">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#aeec1f45196ce8ffe82baf2439e4ee064">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a5129171c03d524afe292aec079397d40">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a15c2b5cf0e52e8da5fbd4d7e32d0aedc">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a87850f01fc632ede64af75d7c20f7a7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string ns3::NamedContentCache::EvictEntry </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict the first content in PolicyIndex and also the corresponding entry in the Cache. This is the main eviction function of <a class="el" href="classns3_1_1NamedContentCache.html" title="The base class for caching data at the ICN Router. ">NamedContentCache</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the evicted content </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a9dda5e2a61f82f7eaa2121a2de2f5a8f">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a2055b9586523ae15979da923dfac65fc">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a657627f6ab6b395086c44bf7e51063fc">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a3440b3cf70e24dd33d511656c0d77112">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a254f3c74475e104a615739fc7577296f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::EvictEntry </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evict the content with corresponding name from both PolicyIndex and Cache. This has to be done when a packet having a content that already exists in the Cache has been received the ICN Router. This operation basically evicts the older entry of the same content so that the newer entry can be inserted. This function has to be defined by all subclasses because every content name in Cache and PolicyIndex has to be unique. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the non-unique content </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#aa04d4be1c2ea84020f5eac561a8ebe22">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a1913c0525f12b726eb04567bb3254551">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#abd2898e58b7eeb214153a29379e05404">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a156013f129c1d13538ed92e6116a2d20">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a081439cd96d09e2f9f158f3aebe9fd7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ptr&lt;Packet&gt; ns3::NamedContentCache::Find </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the content with given name in the Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the content in the form of an Application Layer packet </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#af36841e8b113ed62ad8827785fa03740">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a492b9405dff0ced8bae565bc98f5361c">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a2948736630124fd3a5efcdc69ac04126">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a36311448f4cef69aa4be77dfc91eb3d5">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="afd9ade17d87082a46cbb745fd0196ab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t ns3::NamedContentCache::GetCacheSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the cache size of the Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the cache size of the Cache </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a2d58ee7990ca6ecf0db3fea70bdc09ef">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a923d1d730c8d0171e2366773b950d165">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a7011075202d46dc23358058ed8037125">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#ae94f385620f20825ad07995dccc8075a">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="ac2b0e616d4e866cb2328e986f2ef69e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t ns3::NamedContentCache::GetFreshnessTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the freshness time set for the contents of Cache. </p>
<dl class="section return"><dt>Returns</dt><dd>the freshness time in milliseconds </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a27a3e1d0b4b308a51ccf58dce5df9bee">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a164cda8301046d0123443419528c6b3e">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#ad3f0a3b34a506792f30310761242a86c">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#aa56864aee34859897793284eb7c7f9db">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a6e1837a2d8896d7a53c7a8b1d3a472d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TypeId ns3::NamedContentCache::GetTypeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type ID. </p>
<dl class="section return"><dt>Returns</dt><dd>the object TypeId </dd></dl>

</div>
</div>
<a class="anchor" id="a56a23add9b5bc03908793cf261ccb5f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::InsertToCache </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classns3_1_1NamedContentCacheEntry.html">NamedContentCacheEntry</a>&#160;</td>
          <td class="paramname"><em>entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the Name of the content and its corresponding entry object to the Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
    <tr><td class="paramname">entry</td><td>the cache entry corresponding to the content </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a85d1afb801554e39390c07d07d33d5e7">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a18713ba18ecbf1ef06b0efdf2ef3d83b">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#adfce286e921a3f3d4cbf9e1008cae632">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a2b0a3e5d4d83775f99e6a453bbb9f764">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="ac248e647f56a6fef10285b1c654b8180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::InsertToPolicyIndex </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert the index of the content and its corresponding name to the PolicyIndex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the unique integer index of the content </td></tr>
    <tr><td class="paramname">Name</td><td>name of the content </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a5741df65535e31319d6d534ff1f8aa2f">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#aaeed7c05fc53f6bcb667057b72bfd718">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a8b5e0eb51220cba226f913ddc1ef304f">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a2f6375a96e425628f4ef48df89fc2319">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a281ad340f9771fa2ed898a1ad569d0da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ns3::NamedContentCache::IsEvictable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the content with the given index can be inserted with the eviction of some other content when the is full. The new content can be inserted if its index is lesser than (or greater than, when arranged in descending order) the first content, or if any content's freshness has expired. Some caching policies, like FIFO, keep on inserting new content, irrespective of its index. Subclasses representing such policies need not define and use this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the unique integer index of the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any existing content can be evicted so that the new content with the given index can be inserted. </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a4ac9bfbe6e1b12952c345051517b762f">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a2aaf1a6027c2c635a1c74a7ca279970f">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a29fae4efb96e97023459866634488a28">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a69b633b7e17cb8f13e7a66afb942a258">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a1ceeaf5b85d3571225adfe2d48caf126"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ns3::NamedContentCache::IsFull </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the Cache is full, i.e. if the number of contents is equal the cache size. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the Cache is full </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a791ed7f4bebc707e18852e346f536bd8">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#ab28cafb9e7ea79d7a318d7cafa7293f7">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#ac8cea24f840cdfb15abb1f09638b0fb1">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a15468a5d2fc215b32a8e531944c4197e">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a4c4a79310c99f9c8ad6227d3b380dc20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ns3::NamedContentCache::IsUnique </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>it check whether content is present in the cache or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the content </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if content is not present, false when content is present in the cache </dd></dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a4999cd730f44907c1fdf3f8ea11f4de1">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a3f334cfd08d2a1dbbee280cde3d7fe22">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a8c69352212c41da32499d84add8dd42d">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a90d9c0afe3ef2579dd6faf1f70aeb4e0">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="ae28605a03a5a4d8b9a3494b4068f44e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::SetCacheSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the cache size of the Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the size to which the cache has to be set </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a80bda10cdbc2edca79e6efe8e4fac60e">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#aa6123b2df8e357e30b84edf190d874c8">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a75323b8c1d45dbaa19e07bf6fdf9b9a3">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a6e92a91f36ac87a001644e299be4dd41">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="a92a5e2e641a11d15300f621aa77275ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::SetFreshnessTime </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the freshness time for the contents of Cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>the freshness time in milliseconds </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a3f5fc35d85cee3f4b405ccabd977662b">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a356fd57c44d67a96db68c5dbd0d8471c">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#a0f9e4e62cf6dee79d05774b25ee398c5">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#a7ad5dd349c8ea2633d6c60c0fb5e43ea">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<a class="anchor" id="aeabf8afacd89cbc46b78b382c8a487e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ns3::NamedContentCache::UpdateIndex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the index of the content with the given name. This has to be done when the content is retrieved from Cache to be sent to a querying OICN Client. The subclasses will define this function based on the requirements of the caching policies they represent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>name of the content whose index has to be updated </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classns3_1_1CacheWithLFU.html#a3b6b99b7a3c9a1e8d7fb2c5b2946f69c">ns3::CacheWithLFU</a>, <a class="el" href="classns3_1_1SimpleUniversalCaching.html#a65bbd90a7f126b3f69bbb400a37ef9d0">ns3::SimpleUniversalCaching</a>, <a class="el" href="classns3_1_1CacheWithLRU.html#ad4a24104ec617f5e4fb163a0f7416352">ns3::CacheWithLRU</a>, and <a class="el" href="classns3_1_1CacheWithFifo.html#ae3b39d8b8187650d19806a8950ea9515">ns3::CacheWithFifo</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>model/<a class="el" href="named-content-cache_8h_source.html">named-content-cache.h</a></li>
<li>model/<a class="el" href="named-content-cache_8cc.html">named-content-cache.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 18 2016 10:26:16 for OICNSIM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
